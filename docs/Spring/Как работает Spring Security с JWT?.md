1. **Клиент** получает короткоживущий accessToken (JWT) после успешной аутентификации (логин/пароль, OAuth2 и т.п.).
2. На последующих запросах клиент отправляет заголовок 
   Authorization: Bearer <JWT>.

3. **Фильтр безопасности** перехватывает запрос, извлекает токен, **проверяет**:
 - корректную структуру header.payload.signature (Base64URL);
 - алгоритм подписи (например, HS256 или RS256);
 - валидность подписи токена;
 - стандартные клеймы: exp (не истёк), nbf, iat, а при необходимости — iss, aud, sub, scope/roles.

1. Если всё ок — фильтр создает представление пользователя (principal) с его правами и **кладёт его в контекст безопасности текущего запроса**.

2. Далее **авторизация** на уровне правил доступа (роль/право на эндпоинт, метод и т.д.) просто читает пользователя из контекста и решает «можно/нельзя».

В Spring Security это обычно реализуют отдельным фильтром, который стоит **раньше авторизационных проверок**: он один раз на запрос валидирует JWT и заполняет контекст. Архитектурно важно, что схема **stateless**: сервер не хранит сессию и «доверяет» только проверке подписи и сроков действия токена.