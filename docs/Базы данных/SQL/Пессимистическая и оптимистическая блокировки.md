## **Определения**

#### Пессимистическая блокировка
Явно блокируем нужные строки перед изменением, чтобы конкуренты **ждали** или **падали**. Гарантия отсутствия потери обновлений за счёт ожидания/исключений.
```sql
BEGIN;
-- Эксклюзивно блокируем строки
SELECT * FROM account WHERE id IN (1, 2) FOR UPDATE;          -- ждать
-- варианты поведения
-- ... FOR UPDATE NOWAIT;        -- не ждать, сразу ошибка
-- ... FOR UPDATE SKIP LOCKED;   -- пропустить занятые (очереди)

-- Без потерь меняем
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

**Spring**:
```java
// Репозиторий
@Lock(LockModeType.PESSIMISTIC_WRITE)
Optional<Account> findById(Long id);

// Таймаут блокировки (мс)
@QueryHints(@QueryHint(name="jakarta.persistence.lock.timeout", value="5000"))
@Lock(LockModeType.PESSIMISTIC_WRITE)
Optional<Account> lockForUpdate(Long id);
```

> [!NOTE] Особенности и плюсы/минусы
> ✅ Нет _lost update_ по заблокированным строкам.
> 
> ✅ Детерминированность при высокой конкуренции.
> 
> ⚠️ Риск дедлоков → соблюдайте **единый порядок** блокировок (например, по возрастанию id).
> 
> ⚠️ Долгие транзакции = долгие блокировки → держите транзакции **короткими**.
> 
> ⚠️ **Не защищает предикаты** (в Postgres нет next-key locks): новые строки под ваш WHERE всё равно могут появиться. Для правил «на множество строк» нужен SERIALIZABLE или ограничение (UNIQUE/EXCLUDE).

#### Оптимистическая блокировка
Не блокируем заранее. Каждый апдейт проходит с проверкой **версии** (или хеша/метки времени).  При конкурентном изменении возникает **конфликт версии** → откат и повтор/ошибка.

```sql
-- одна колонка для версии
ALTER TABLE doc ADD COLUMN version int NOT NULL DEFAULT 0;

-- попытка обновить, если версия совпала
UPDATE doc
SET content = :newContent, version = version + 1
WHERE id = :id AND version = :oldVersion
RETURNING *;    -- 0 строк => конфликт → повторить/сообщить
```

**Spring:**
```java
@Entity
class Doc {
  @Id Long id;
  @Version int version;     // колонка version в таблице
}

@Transactional
public void updateDoc(Long id, String text) {
  Doc d = repo.findById(id).orElseThrow();
  d.setContent(text);       // при коммите JPA проверит version и ++(инкремент)
}
```

> [!NOTE] Особенности и плюсы/минусы
> 
> ✅ Нет блокировок заранее → лучше масштабируется при **редких конфликтах**.
> 
> ✅ Прекрасно подходит для UI-редактирования («кто-то уже изменил документ»).
> 
> ⚠️ При **частых конфликтах** много ретраев/ошибок → может быть хуже пессимизма.
> 
> ⚠️ Всё равно нужны атомарные выражения (SET qty = qty-1) для read-modify-write.


#### Когда какую выбирать (шпаргалка)

- **Редкие конфликты, пользовательские правки, коллаборация:**
- **Оптимистическая** (@Version, ETag), конфликт показываем пользователю/повторяем.

- **Частые конфликты, короткие критические секции, важно «пропустить только по одному»:**
- **Пессимистическая** (FOR UPDATE / PESSIMISTIC_WRITE).

- **Очереди/раздача задач пакетами:**
- Пессимизм с SKIP LOCKED.

- **Инварианты по множеству строк (квоты, бронирования, «непересекается») :**
- Лучше **ограничение** (UNIQUE partial / EXCLUDE) или **SERIALIZABLE + retry**. Пессимизм одной строки не спасёт.

- **Обычные CRUD и счётчики:**
- READ COMMITTED + **атомарные UPDATE** (без предварительного SELECT).