### Уровни изоляции

#### READ UNCOMMITTED (в PostgreSQL)

**Как это работает:** Позволяет читать незакомиченные изменения, что может привести к неверному чтению данных.

**Когда использовать:** лучше никогда
#### READ COMMITTED (по умолчанию в PostgreSQL)

**Как это работает:** каждый отдельный запрос видит актуальный на его старт снэпшот (снимок).

**Когда использовать:** делаем атомарные апдейты на стороне базы данных, либо в некоторых случаях мы делаем пессимистичные блокировки *прим. FOR UPDATE* , т.к. возможны _non-repeatable read_ и _phantom_, а также риск _lost update_ при паттерне read-modify-write без блокировок. Данную блокировку используем чаще всего при работе с БД.
#### REPEATABLE READ (Snapshot Isolation)

**Как это работает:** один общий снэпшот (снимок) на всю транзакцию, все наши SELECT будут видеть одно и то же состояние.

**Когда использовать:** надо произвести какие-то расчеты, составить отчеты, где нужно стабильное чтение, да, возможен **write skew** — инвариант “на множество строк” может сломаться.

> [!NOTE] Что такое **инвариант по множеству строк**?
> Это бизнес-правило, зависящее **не от одной строки**, а от **набора** строк в таблице (или нескольких таблицах). Формально: есть предикат P(R), зависящий от нескольких кортежей отношения R, и он должен быть истинным при каждом COMMIT.
> - **Инвариант** — это правило корректности, которое должно держаться всегда; в БД — после каждого COMMIT, в классе — после каждого публичного метода, в цикле — после каждой итерации. Выражай его там, где система может его **жёстко гарантировать** (ограничения БД, индексы, атомарные операции, корректные уровни изоляции).
> - **Кортеж** (_tuple_) — это одна **запись** (строка) в отношении (таблице).
> - **Предикат** — это логическое выражение (**булева функция**), которое на вход получает кортеж (или набор кортежей) и возвращает TRUE/FALSE _(в SQL ещё и_ _UNKNOWN_ _из-за_ _NULL__)_.

#### SERIALIZABLE (Serializable Snapshot Isolation, SSI)

**Как это работает:** транзакции выполняются последовательно в каком-то порядке.

**Когда использовать:** избежать write skew, а также если мы совершаем транзакции с деньгами, лимитами, бронированиями. Используем(!) точечно для критичных инвариантов.

**Какие минусы:** данный уровень изоляции может повлечь за собой *serialization_failure* из-за чего придется перезапускать транзакцию (*retry*), как следствие возрастают затрачиваемые ресурсы и снижается пропускная способность.

**Советы:** 
- Транзакции в данном случае должны быть короткими, не надо забывать про *retry*
- Если инвариант можно выразить **ограничением** (UNIQUE/EXCLUDE USING gist/атомарные счётчики) — лучше сделайте это и оставайтесь на READ COMMITTED
### Аномалии при работе с базами данных

**Dirty-read (грязное чтение)** - ситуация, при которой одна транзакция может прочитать изменения другой транзакции, при этом эти изменения ещё не закоммичены. 

> [!NOTE] NB
> 
> В **PostgreSQL dirty read невозможен**: даже READ UNCOMMITTED трактуется как READ COMMITTED, и MVCC не покажет незакоммиченные версии.
> В других БД, например, MySQL лучше не использовать грязное чтение и READ UNCOMMITED, так как всегда есть риск получить несуществующие данные, если в другой транзации случился ROLLBACK.

**Non-repeatable read** - одна и та же строка читается по-разному в пределах одной транзакции.

> [!NOTE] NB
> В READ COMMITTED каждый **запрос** берёт свой снимок (MVCC-snapshot). Поэтому между двумя SELECT в одной транзакции вы можете увидеть **разные данные**.

**Пример:**
*Т1 и Т2 - транзакция 1 и транзакция 2 соответственно*

**Создаем таблицу (подготовка):**
``` SQL
CREATE TABLE acct(id int primary key, balance int);
INSERT INTO acct VALUES (1, 100);
COMMIT;
```

**T1:**
``` SQL
BEGIN;  -- уровень по умолчанию READ COMMITTED
SELECT balance FROM acct WHERE id = 1;  -- ⇒ 100
-- (пауза, имитируем работу приложения)
```

**Запускаем параллельно Т2**
``` sql
BEGIN;
UPDATE acct SET balance = 150 WHERE id = 1;
COMMIT;  -- изменение стало видимым для новых запросов
```

**А теперь снова Т1**
``` sql
SELECT balance FROM acct WHERE id = 1;  -- ⇒ 150  (значение изменилось)
COMMIT;
```

> [!NOTE] Что на самом деле случилось?
Первый SELECT в T1 видел старый снапшот (100), второй SELECT — уже новый снапшот после коммита T2 (150). Это и есть _non-repeatable read_.
> 

**Но, этого можно избежать:**
**Вариант номер раз:**
*Поднимаем изоляцию*
``` sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT balance FROM acct WHERE id = 1;  -- ⇒ 100
-- параллельно T2 делает UPDATE... COMMIT
SELECT balance FROM acct WHERE id = 1;  -- ⇒ 100  (тот же снимок на всю транзакцию)
COMMIT;
```

**Вариант номер два**

> [!NOTE] NB
> Ведь нам не всегда нужно поднимать уровень изоляции, потому что нам будет нужен доступ к строкам по ключу, и нужно постоянно видеть обновления. Snapshot в случае с REPEATABLE READ видит всю таблицу целиком, это стабильный снимок, а бывают случаи когда нужен точечный и постоянный доступ к данным. **Поэтому оставляем READ COMMITED и делаем пессимистическую блокировку.**

``` sql
BEGIN;
SELECT * FROM acct WHERE id = 1 FOR UPDATE;  -- блокируем строку

-- параллельно T2: UPDATE ...  ← будет ждать COMMIT/ROLLBACK T1

SELECT balance FROM acct WHERE id = 1;  -- стабильно то же значение
COMMIT;  -- теперь T2 разблокируется
```

**Phantom Read** — это _новая строка, удовлетворяющая предикату_, появляющаяся между двумя запросами одной транзакции.

**Создаем таблицу**
``` SQL
CREATE TABLE booking(
  id bigserial PRIMARY KEY,
  room_id int NOT NULL,
  day date NOT NULL
);
INSERT INTO booking(room_id, day) VALUES (1, '2025-08-24'), (1, '2025-08-24'), (1, '2025-08-24');
COMMIT;
```

**T1:**
```sql
BEGIN; -- уровень по умолчанию READ COMMITTED
SELECT count(*) FROM booking WHERE room_id=1 AND day='2025-08-24';  -- ⇒ 3
-- (делаем паузу)
```

**T2 (параллельно):**
```sql
BEGIN;
INSERT INTO booking(room_id, day) VALUES (1, '2025-08-24');
COMMIT; -- новая строка подходит под предикат T1
```

**Снова Т1:**
```sql
SELECT count(*) FROM booking WHERE room_id=1 AND day='2025-08-24';  -- ⇒ 4  ← фантом
COMMIT;
```

> [!NOTE] Что на самом деле тут случилось?
> В READ COMMITTED **каждый запрос** берёт свежий снимок, и второй SELECT увидит строку, которую T2 успела закоммитить. Чтобы этого избежать мы можем поднять уровень до REPEATABLE READ или SERIALIZABLE, или избегать отдельных запросов и составлять запрос с ограничением.


**Write skew** — это нарушение инварианта при параллельных транзакциях, когда обе читают один и тот же _набор_ данных, а затем **обновляют разные строки**, проходя мимо прямых конфликтов и блокировок. На REPEATABLE READ в PostgreSQL (snapshot isolation) оно **возможно**. На SERIALIZABLE — **будет предотвращено** отменой одной транзакции (нужен retry).

Давай с тобой глянем как это происходит на практике, тут будем использовать REPEATABLE READ, на котором Write Skew проявляется:

**Инвариант:** в смене всегда ≥ 1 врач on_call = TRUE.
```sql
CREATE TABLE doctors(
  id int PRIMARY KEY,
  on_call boolean NOT NULL
);
INSERT INTO doctors VALUES (1, TRUE), (2, TRUE);
COMMIT;
```

**T1:**
```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT count(*) FROM doctors WHERE on_call = TRUE;  -- ⇒ 2
UPDATE doctors SET on_call = FALSE WHERE id = 1;
-- (не коммитим пока)
```

**T2 (параллельно):**
```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT count(*) FROM doctors WHERE on_call = TRUE;  -- ⇒ 2 (тот же «старый» снапшот)
UPDATE doctors SET on_call = FALSE WHERE id = 2;
COMMIT;  -- проходит
```

T1:
```sql
COMMIT;  -- тоже проходит
```

> [!NOTE] Что на самом деле здесь происходит?
> Обе транзакции закоммитились, стало 0 on_call → инвариант сломан, хотя конфликтов по одной строке не было.
> Почему так? MVCC даёт «снимок» на всю транзакцию: каждая T видит старую картину (2 on_call), а пишет в **разные** строки — конфликтов по row-lock нет.

| **Уровень**         | **Dirty Read** | **Non-repeatable** | **Phantom** | **Write Skew** | **Примечания**                                                                                           |
| ------------------- | -------------- | ------------------ | ----------- | -------------- | -------------------------------------------------------------------------------------------------------- |
| **READ COMMITTED**  | ✗              | ✔                  | ✔           | ✔              | Быстрый дефолт. Защищайтесь FOR UPDATE/атомарными UPDATE ... SET col = col ± x.                          |
| **REPEATABLE READ** | ✗              | ✗                  | ✗*          | ✔              | Снимок на транзакцию; _в SELECT’ах фантомы не видны, но инварианты всё ещё могут ломаться (write skew)._ |
| **SERIALIZABLE**    | ✗              | ✗                  | ✗           | ✗              | Самый строгий; возможны отмены транзакций → закладываем **retry**.                                       |
[[Пессимистическая и оптимистическая блокировки]]