## Аномалии при работе с базами данных

**Dirty-read (грязное чтение)** - ситуация, при которой одна транзакция может прочитать изменения другой транзакции, при этом эти изменения ещё не закоммичены. 

> [!NOTE] NB
> 
> В **PostgreSQL dirty read невозможен**: даже READ UNCOMMITTED трактуется как READ COMMITTED, и MVCC не покажет незакоммиченные версии.
> В других БД, например, MySQL лучше не использовать грязное чтение и READ UNCOMMITED, так как всегда есть риск получить несуществующие данные, если в другой транзации случился ROLLBACK.

**Non-repeatable read** - одна и та же строка читается по-разному в пределах одной транзакции.

> [!NOTE] NB
> В READ COMMITTED каждый **запрос** берёт свой снимок (MVCC-snapshot). Поэтому между двумя SELECT в одной транзакции вы можете увидеть **разные данные**.

**Пример:**
*Т1 и Т2 - транзакция 1 и транзакция 2 соответственно*

**Создаем таблицу (подготовка):**
``` SQL
CREATE TABLE acct(id int primary key, balance int);
INSERT INTO acct VALUES (1, 100);
COMMIT;
```

**T1:**
``` SQL
BEGIN;  -- уровень по умолчанию READ COMMITTED
SELECT balance FROM acct WHERE id = 1;  -- ⇒ 100
-- (пауза, имитируем работу приложения)
```

**Запускаем параллельно Т2**
``` sql
BEGIN;
UPDATE acct SET balance = 150 WHERE id = 1;
COMMIT;  -- изменение стало видимым для новых запросов
```

**А теперь снова Т1**
``` sql
SELECT balance FROM acct WHERE id = 1;  -- ⇒ 150  (значение изменилось)
COMMIT;
```

> [!NOTE] Что на самом деле случилось?
Первый SELECT в T1 видел старый снапшот (100), второй SELECT — уже новый снапшот после коммита T2 (150). Это и есть _non-repeatable read_.
> 

**Но, этого можно избежать:**
**Вариант номер раз:**
*Поднимаем изоляцию*
``` sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT balance FROM acct WHERE id = 1;  -- ⇒ 100
-- параллельно T2 делает UPDATE... COMMIT
SELECT balance FROM acct WHERE id = 1;  -- ⇒ 100  (тот же снимок на всю транзакцию)
COMMIT;
```

**Вариант номер два**

> [!NOTE] NB
> Ведь нам не всегда нужно поднимать уровень изоляции, потому что нам будет нужен доступ к строкам по ключу, и нужно постоянно видеть обновления. Snapshot в случае с REPEATABLE READ видит всю таблицу целиком, это стабильный снимок, а бывают случаи когда нужен точечный и постоянный доступ к данным. **Поэтому оставляем READ COMMITED и делаем пессимистическую блокировку.**

``` sql
BEGIN;
SELECT * FROM acct WHERE id = 1 FOR UPDATE;  -- блокируем строку

-- параллельно T2: UPDATE ...  ← будет ждать COMMIT/ROLLBACK T1

SELECT balance FROM acct WHERE id = 1;  -- стабильно то же значение
COMMIT;  -- теперь T2 разблокируется
```

**Phantom Read** — это _новая строка, удовлетворяющая предикату_, появляющаяся между двумя запросами одной транзакции.

**Создаем таблицу**
``` SQL
CREATE TABLE booking(
  id bigserial PRIMARY KEY,
  room_id int NOT NULL,
  day date NOT NULL
);
INSERT INTO booking(room_id, day) VALUES (1, '2025-08-24'), (1, '2025-08-24'), (1, '2025-08-24');
COMMIT;
```

**T1:**
```sql
BEGIN; -- уровень по умолчанию READ COMMITTED
SELECT count(*) FROM booking WHERE room_id=1 AND day='2025-08-24';  -- ⇒ 3
-- (делаем паузу)
```

**T2 (параллельно):**
```sql
BEGIN;
INSERT INTO booking(room_id, day) VALUES (1, '2025-08-24');
COMMIT; -- новая строка подходит под предикат T1
```

**Снова Т1:**
```sql
SELECT count(*) FROM booking WHERE room_id=1 AND day='2025-08-24';  -- ⇒ 4  ← фантом
COMMIT;
```

> [!NOTE] Что на самом деле тут случилось?
> В READ COMMITTED **каждый запрос** берёт свежий снимок, и второй SELECT увидит строку, которую T2 успела закоммитить. Чтобы этого избежать мы можем поднять уровень до REPEATABLE READ или SERIALIZABLE, или избегать отдельных запросов и составлять запрос с ограничением.


**Write skew** — обе транзакции читают согласованную картину, **каждая** вносит изменение в свою строку, **в сумме** нарушая правило (“инвариант”), хотя **прямых конфликтов по одной строке нет**.



| **Уровень**         | **Dirty Read** | **Non-repeatable** | **Phantom** | **Write Skew** | **Примечания**                                                                                           |
| ------------------- | -------------- | ------------------ | ----------- | -------------- | -------------------------------------------------------------------------------------------------------- |
| **READ COMMITTED**  | ✗              | ✔                  | ✔           | ✔              | Быстрый дефолт. Защищайтесь FOR UPDATE/атомарными UPDATE ... SET col = col ± x.                          |
| **REPEATABLE READ** | ✗              | ✗                  | ✗*          | ✔              | Снимок на транзакцию; _в SELECT’ах фантомы не видны, но инварианты всё ещё могут ломаться (write skew)._ |
| **SERIALIZABLE**    | ✗              | ✗                  | ✗           | ✗              | Самый строгий; возможны отмены транзакций → закладываем **retry**.                                       |